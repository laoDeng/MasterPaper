%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[UTF8]{ctexart}
\title{第四章 SerDes接收端数据链路层设计}
\author{陈登}
\date{\today}

\bibliographystyle{plain}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\geometry{a4paper,centering,scale=0.9}
\usepackage[format=hang,font=small,textfont=it]{caption}
\usepackage[toc,page,title,titletoc,header]{appendix} 
\usepackage[nottoc]{tocbibind}

\newcommand\kw{\textbf}

\begin{document}

\section{SerDes接收端数据链路层设计}

\subsection{8B/10B解码器设计}

根据JESD204B协议规定，SerDes接口为保证信内数据的直流平衡，并且为了便于时钟恢复，采用8B/10B码作为数据链路层的编码方式。
JESD204B中采用的8B/10B编解码部分主要参考IEEE802.3以太网协议中关于8B/10B的编解码部分。
但是由于应用环境的不同，JESD204B协议的8B/10B编解码方式同以太网相比略有不同。

\subsubsection{协议分析}

以太网协议提供了完整的编码表，也可以看作为解码表，这几张表格的正确性毋庸置疑，是最值得参考的资料。
表中将总共268种的编码情况全部列出，可以作为校验编码正确性的基准值。

在数字编码中有一个重要的概念，叫做极性\footnote{RD，即Running Disparity}。
极性是指一组编码中0的个数和1的个数之差，在一定长度的编码情况下，可以理解为0或1的个数。
比如说3B/4B编码中，在4B编码结果中，若1的个数多余0的个数则称为正极性，反之称为负极性，二者相同则称为平衡。
事实上，在具体的数据字编码中，不会出现编码结果0的个数多余1的个数三个或以上.
若编码中1的个数减去0的个数记，无论6B或者4B的编码结果只会为-2,0,2，相对应与负极性、平衡和正极性。

以太网协议建议，将一个码组的极性分为三部分，第一是上一码组计算后得出的极性，第二是编码后6B部分的极性，第三是编码后4B部分的极性。
而最后得到的4B部分的极性将作为这一组码的极性用于接下来码组的计算。
极性运算的基本结构：$last\_code\_group\_RD \to 6B\_sub\_block \to 6B\_RD \to 4B\_sub\_block \to 4B\_RD(new\_last\_code\_group\_RD)$。

每个sub-block的判断可用以下伪代码表示（6B和4B略有不同）：

\begin{tabbing}
\qquad\=\kw{if} $000111$ or $0011$ or $1s>0s$ \\
      \>\qquad$6B\_RD=+;RD\_4B=+;$ \\
      \>\kw{else if} $111000$ or $1100$ or $1s<0s$ \\
      \>\qquad$6B\_RD=-;RD\_4B=-;$ \\
      \>\kw{else} \\
      \>\qquad$6B\_RD=last\_code\_group\_RD;$ \\
      \>\qquad$4B\_RD=6B\_RD;$ \\
      \>\kw{endif}
\end{tabbing}

最后是以太网协议中关于极性错误的处理，在协议附录中给出了一些接收当中的极性错误。
可以发现，极性错误是不能精确定位的，它的检测主要是通过接收机本地的极性和所接收到的极性不符所产生的错误。
但由于一系列的中性码并不会改变极性，前一码接收产生的错误可能因为一系列的中性码而直到几个码字后才能检测到。

在JESD204B协议中关于8B/10B编解码的规定，阅读接口协议的数据链路层内容，可以发现，在编解码器之前还有一级控制，主要是用来针对数据成帧结构中的lane、frame、multiframe的校准、同步和错误控制，而控制的依据就是解码器中获得的控制字。

在JESD204B协议中只用到了8B/10B所用控制字的5个，这将简化控制字的解码复杂度，控制字分别如下：

\begin{description}
\item[K.29.0] 即D，表示Multiframe的开始。
\item[K.28.3] 即A，表示Lane校准，一般在多帧最后出现。
\item[K.28.4] 即Q，表示Link设置数据的开始，在他之后跟一系列设置数据，配置Link，他也是ILAS\footnote{Initial Lane Alignment Sequence}的组成部分。
\item[K.28.7] 即K，表示Group同步，可以说是链接开头最重要的部分，用来保持同步，是CGS\footnote{Code Group Synchronization}的重要控制字。
\item[K.28.7] 即F，表示Frame校准，一般表示一帧结束。
\end{description}

JESD204B协议还规定了三种重要的解码错误，这些在解码器级别的错误是属于不太严重的错误，有可能经常发生，在错误并不严重的情况下并不需要进行重同步，但是需要上报给错误处理部分，供应用层决定如何处理。

错误包括以下三种：

\begin{description}
\item[Not-in-table Error] 这种错误意味着接收到的码字在任何极性情况下都不存在于码表中，就是一些非法的码字。对于这些码字，协议规定接收端需要重复之前收到的最新的没有错误的帧。
\item[Running Disparity Error] 这种错误就是上文提到的极性错误，协议规定解码器要根据收到的数据和极性直接解码。由于在检测到极性错误时，可能产生错误的不是这个码字，这样的处理方式也比较合理。
\item[Unexpected Control Character] 这种错误就是指未出现在指定位置的控制字，这一错误的具体处理需要由lane/frame监测部分来决定，属于接下来层级的处理，解码器并无法判断出这一错误。
\end{description}

\subsubsection{解码思路}

具体逻辑框图如图\ref{fig:8b10b_decoder_diagram}所示。

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{./img/8b10b_decoder_diagram.pdf}
\caption{8B/10B解码器系统框图}
\label{fig:8b10b_decoder_diagram}
\end{figure}

通过对现有论文编解码方式的理解分析，可以发现编码的方式比较多样，但解码仍主要停留在通过逻辑的方式。
在\cite{zhaoyh2003}、\cite{hecf2005}和\cite{Widmer1983}中采用的是纯逻辑解码方式；在\cite{wenl2007}和\cite{Actel1998}这两篇文章中采用的是多路选择器的方式。

在现有文章的解码中，极性仅作为差错检测，这是一种对信号资源的浪费，如果通过极性来进行解码，可以更好的利用现有的码表。
对于已知码组的极性信息，可以得出下一组码可能的编码情况，这时就可以通过取反操作来压缩解码表的大小，更快的处理解码操作。
例如，已知前一组码字的极性信息为$RD+$，则可以推测出接下来的$6B$数据的极性信息只有可能为$RD-$或者均衡两种可能。
因此只需要处理一种极性的码字就可以完成对整个编码的解码，复杂度变为原来的一半。

对于数据字而言，在获知当前$RD$状态的前提下，解码就分为两种情况。
一种是相反的极性，还有一种是均衡的极性。
对于相反的极性而言，不需要对另一种极性解码，整张解码用表就可以缩小一半，一方面节约了芯片面积额，一方面提高了解码效率。
对于均衡极性而言，由\cite{Widmer1983}中编码原理分析可知，对于均衡码的解码其实非常简便，只需要输出其低$5$或$3$位。
因此，只需要设计一个均衡码判断电路，就可以快速选择是否通过解码逻辑极性解码。

对于控制字而言，由\cite{Actel1998}中提到的控制信息检测可以发现，通过$RD$和固定位置的比特就可以区分该码字是否为控制字，并且确定是哪一类控制字($K.28.x$还是$K.23.7$、$K.27.7$、$K.29.7$、$K.30.7$)。
在分析编码可知，控制字的$3B$或$5B$部分的编码规则同数据字是相同的。那么就可以“借用”数据字的解码部分来对控制字部分解码，准确输出控制码字。
其中包括了均衡和非均衡的情况，处理逻辑同数据字，唯一不同的就是控制字状态标记是否拉高。

最后对于解码模块的考虑，一般情况下都是采用的是verilog语言的case逻辑，但是对于高效的电路来说要尽量避免对语言原生性能的依赖。
通过逻辑化简的方法对更小的码表进行化简，这样的得到表达式速度更快，并且面积较小。

\subsubsection{第一级，预处理级}

预处理级系统框图如图\ref{fig:8b10b_preprocess_model}所示。

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{./img/8b10b_preprocess_model.pdf}
\caption{8B/10B解码器预处理级框图}
\label{fig:8b10b_preprocess_model}
\end{figure}

\paragraph{K Bit检测}

根据输入完整的$10B$数据判断是否为控制信号。
有以下伪代码：

\begin{tabbing}
\qquad\=\kw{if} $iedc==1111|0000$ \\
      \>\qquad$K.28.x=1;K.x.7=0;$ \\
      \>\kw{else if} $jhgfie==010111|101000$ \\
      \>\qquad$K.28.x=0;K.x.7=1;$ \\
      \>\kw{else} \\
      \>\qquad$K.28.x=0;K.x.7=0;$ \\
      \>\kw{endif}
\end{tabbing}

本设计中的8B/10B编码，只采用了6B部分为K.28的控制字。
由完整检测逻辑可以得出，只需要检测6B部分的cdei位是否为0000或者1111，就能判断出结果。
所以判断控制字本设计可以采用最简单的逻辑表达式：

$$K\_bit = (c \& d \& e \& i)\quad|\quad~(c | d | e | i)$$

\paragraph{$6B$和$4B$平衡检测}

就是对给出的并行数据，分别输出$6B$和$4B$是否平衡，平衡即指0和1的数量是否相同。
有以下伪代码\footnote{其中$RL$表示游程长度计算，即$1$的个数。下同。}：

\begin{tabbing}
\qquad\=\kw{if} $RL(6B)==3$ \\
      \>\qquad$Balance\_6B=1;$ \\
      \>\kw{else} \\
      \>\qquad$Balance\_6B=0;$ \\
      \>\kw{endif}
\end{tabbing}

\begin{tabbing}
\qquad\=\kw{if} $RL(4B)==2$ \\
      \>\qquad$Balance\_4B=1;$ \\
      \>\kw{else} \\
      \>\qquad$Balance\_4B=0;$ \\
      \>\kw{endif}
\end{tabbing}

\paragraph{RD信息检测}

RD信息检测主要指分别计算6B和4B部分的极性，每一部分又分别有两个输出，$RD-$和$RD+$。
因为每一组码字的极性一共存在三种可能，即正、负和平衡，不属于负和正的码字，既为平衡，平衡的判断也可由上文中的伪代码确定。
这些重要的信息主要用于极性错误检测和解码。
通过对合法码字的真值表进行化简，可以得到快速RD极性检测模块，准确输出正确码字RD的负和正信号。

最终模块输出4个信号，即RD\_6B\_pos、RD\_6B\_neg、RD\_4B\_pos、RD\_4B\_neg。

\paragraph{NIT错误检测}

Not-In-Table Error的检测也分为4B和6B两部分。

6B部分的错误码字一共为14种，如表\ref{tab:tab_6B_NIT_err}，参考\cite{Widmer1983}一文的方法可以分为两类，既考虑abcd全为0或全为1的情况和abcd有且仅有1个1或仅有1个0的情况。
前者直接可以判断该码字为错误码字，后者再观察ef是否全为0或全为1，也可判断码字是否错误。

4B部分的错误码字相对较为复杂，考虑到K.28中只有5个控制字是合法的，所以要对余下的码字报错。
4B部分报错情况如表\ref{tab:tab_4B_NIT_err}所示。

\begin{table}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\caption{6B码字错误情况}
\label{tab:tab_6B_NIT_err}
\begin{tabular}{|c|r|r|r|}
\hline
	abcdei	&	abcdei	\\
\hline
	000000	&	111111	\\
	000001	&	111110	\\
	000010	&	111101	\\
	000100	&	111011	\\
	001000	&	110111	\\
	010000	&	101111	\\
	100000	&	011111	\\
\hline
\end{tabular}
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
\centering
\caption{4B码字错误情况}
\label{tab:tab_4B_NIT_err}
\begin{tabular}{|c|r|r|r|}
\hline
	abcdei	&	hgfj	\\
\hline
	xxxxxx	&	0000	\\
			&	1111	\\
\hline
	001111	&	0101	\\
			&	1001	\\
			&	0110	\\
\hline
	110000	&	1010	\\
			&	1001	\\
			&	0110	\\
\hline
\end{tabular}
\end{minipage}
\end{table}

\subsubsection{极性错误检测}

极性错误检测部分负责检测关于极性的错误，主要就是指不能出现连续相同的极性变化。
例如之前一个码字的RD为RD-，则接下来收到的6B编码的RD必须为均衡或者是RD+，这样就保证了信道上码字的均衡。
极性检测实际上考虑的是三个部分的信息，可以细化为五个信号，包括上一个码字的极性，当前码字6B部分的RD+或RD-，当前码字4B部分的RD+或RD-。
极性错误的监测并不能精确定位，因为均衡的码字是无法判断出是否有错的，只有当数据扩散到非均衡位置时才能判断出错误。
由于正确的检测需要保存上一码字的极性信息，所以极性错误检测还负责解码器极性的刷新。
检测可以通过极性信息计算模块提供的信号进行判断，并将得到新的极性存入寄存器，如表\ref{tab:tab_RD_err}所示。

\begin{table}[H]
\centering
\caption{极性错误检测及新极性生成表}
\label{tab:tab_RD_err}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
	last	&	6B+	&	6B-	&	4B+	&	4B-	&	err	&	new	\\
\hline
	0 	 	&	0 	&	0 	& 	0	&	0 	&	0 	&	0 	\\
	0 	 	&	0 	&	0 	& 	0	&	1 	&	1 	&	0 	\\
	0 	 	&	0 	&	0 	& 	1	&	0 	&	0 	&	1 	\\
	0 	 	&	0 	&	1 	& 	0	&	0 	&	1 	&	0 	\\
	0 	 	&	0 	&	1 	& 	0	&	1 	&	1 	&	0 	\\
	0 	 	&	0 	&	1 	& 	1	&	0 	&	1 	&	1 	\\
	0 	 	&	1 	&	0 	& 	0	&	0 	&	0 	&	1 	\\
	0 	 	&	1 	&	0 	& 	0	&	1 	&	0 	&	0 	\\
	0 	 	&	1 	&	0 	& 	1	&	0 	&	1 	&	1 	\\
	1 	 	&	0 	&	0 	& 	0	&	0 	&	0 	&	1 	\\
	1 	 	&	0 	&	0 	& 	0	&	1 	&	0 	&	0 	\\
	1 	 	&	0 	&	0 	& 	1	&	0 	&	1 	&	1 	\\
	1 	 	&	0 	&	1 	& 	0	&	0 	&	0 	&	0 	\\
	1 	 	&	0 	&	1 	& 	0	&	1 	&	1 	&	0 	\\
	1 	 	&	0 	&	1 	& 	1	&	0 	&	0 	&	1 	\\
	1 	 	&	1 	&	0 	& 	0	&	0 	&	1 	&	1 	\\
	1 	 	&	1 	&	0 	& 	0	&	1 	&	1 	&	0 	\\
	1 	 	&	1 	&	0 	& 	1	&	0 	&	1 	&	1 	\\
\hline
\end{tabular}
\end{table}

根据此表化简逻辑表达式即可得到准确的极性错误和本码字的极性情况。
也可以采用有限状态机的方法进行判断，通过几个固定的状态转换进行极性的判断和存储了\cite{AlKafi2013}。
极性状态转移图如图\ref{fig:8b10b_running_disparity_status}所示。

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{./img/8b10b_running_disparity_status.pdf}
\caption{8B/10B Running Disparity状态转移图}
\label{fig:8b10b_running_disparity_status}
\end{figure}

\subsubsection{第二级，解码级}

解码级系统框图如图\ref{fig:8b10b_decoder_model}所示。

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{./img/8b10b_decoder_model.pdf}
\caption{8B/10B解码器解码级框图}
\label{fig:8b10b_decoder_model}
\end{figure}

解码输入的第一步就是根据极性情况，对输入码字进行反转。
根据8B/10B原理，对于相同的原始码字编码，在不同极性情况下的变化就是互为反码。
所以在知道具体码字的极性信息时对其进行反转就可以准确的得到同极性下的编码，使之后的解码器只需要处理一种极性。
具体的反转判断伪代码如下：

\begin{tabbing}
\qquad\=\kw{if} $RD==RD+$ \\
      \>\qquad$6B=6B;$ \\
      \>\kw{else} \\
      \>\qquad$6B=!6B;$ \\
      \>\kw{endif}
\end{tabbing}

\begin{tabbing}
\qquad\=$RD\_6=RD|Balance\_6B$ \\
      \>\kw{if} $RD\_6==RD+$ \\
      \>\qquad$4B=4B;$ \\
      \>\kw{else} \\
      \>\qquad$4B=!4B;$ \\
      \>\kw{endif}
\end{tabbing}

$6B/5B$和$4B/3B$解码部分，主要根据解码表对输入码字解码。
解码表中存的查找项均为极性为正时的解码，根据输入输出解码结果，5B/6B解码部分解码表如表\ref{tab:tab_6B_tab}所示，3B/4B解码部分解码表如表\ref{tab:tab_4B_tab}所示。

需要特别注意的是3B/4B解码部分，不同于5B/6B解码，3B/4B解码还需要考虑控制字的信息。
这是因为对于特定的控制字K.28来说，为了避免整个10B编码偶然的出现连续5个0或1，解码器就要根据情况来选择不同的3B编码。
在解码过程中要着重考虑到这一点，为此增加了K位作为解码输入条件之一，K位即表示控制位，由预处理级的控制字检测电路产生。
通过化简增加信息后的真值表，得到表达式用以解码。

最后需要考虑的是均衡码字的情况，这种情况可以由之前的极性信息直接推断出来，这时候解码器需要做的就是输出相应解码部分的低位。

不同于\cite{Actel1998}文中所描述的CASE方法，也不同于\cite{Widmer1983}中的纯逻辑方法。
本设计引入了各个模块的$RD+$信息，在读入数据之前先根据RD\_pos信息对码字进行反转。
这样，在解码时只要考虑$RD$为$RD-$和平衡的情况。
对于6B解码表由原来的48种情况减少为34种（如表\ref{tab:tab_6B_tab}所示）；对于4B解码表，由于其解码需要考虑K Bit的情况，由原来的28种情况减少为16种（如表\ref{tab:tab_4B_tab}所示）。
并且由于快速的极性信息计算，使得解码模块能够更快的进行解码，缩短了解码所需时间。
最后通过逻辑化简的方法对更小的码表进行化简，这样的得到表达式速度更快，并且面积较小。

\begin{table}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\caption{6B解码表}
\label{tab:tab_6B_tab}
\begin{tabular}{|c|c|c|c|}
\hline
	abcdei	&	EDCBA	&	abcdei	&	EDCBA	\\
\hline
	000011	&	11100	&	011001	&	11001	\\
	000101	&	01111	&	011010	&	11010	\\
	000110	&	00000	&	011100	&	11100	\\
	000111	&	00111	&	100001	&	11110 	\\
	001001	&	10000	&	100010	&	11101 	\\
	001010	&	11111	&	100011	&	00011 	\\
	001011	&	01011	&	100100	&	11011 	\\
	001100	&	11000	&	100101	&	00101 	\\
	001101	&	01101	&	100110	&	00110 	\\
	001110	&	01110	&	101000	&	10111 	\\
	010001	&	00001	&	101001	&	01001 	\\
	010010	&	00010	&	101010	&	01010 	\\
	010011	&	10011	&	101100	&	01100 	\\
	010100	&	00100	&	110001	&	10001 	\\
	010101	&	10101	&	110010	&	10010 	\\
	010110	&	10110	&	110100	&	10100 	\\
	011000	&	01000	&	111000	&	00111 	\\
\hline
\end{tabular}
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
\centering
\caption{4B解码表}
\label{tab:tab_4B_tab}
\begin{tabular}{|c|c|c|}
\hline
	K	&	hgfj	&	HGF	\\
\hline
	0	&	0001	&	111	\\
	0	&	0010	&	000	\\
	0	&	0011	&	011	\\
	0	&	0100	&	100	\\
	0	&	0101	&	101	\\
	0	&	0110	&	110	\\
	0	&	1000	&	111	\\
	0	&	1001	&	001	\\
	0	&	1010	&	010	\\
	0	&	1100	&	011	\\
	1	&	0001	&	111	\\
	1	&	0010	&	000	\\
	1	&	0011	&	011	\\
	1	&	0100	&	100	\\
	1	&	1010	&	101	\\
	1	&	1100	&	011	\\
\hline
\end{tabular}
\end{minipage}
\end{table}

\subsection{解扰器设计}

JESD204的发送端和接收端设备都需要支持加扰传输的数据流。
并且每一对lane都要包含加扰器和解扰器。
加扰器和解扰器的位置位于数据链路层和传输层之间，也就是位于8B/10B解码器之后进行解扰，加扰后进行编码。
所以加扰操作主要是针对数据进行的，不涉及链路上的控制字符。
对一个link启动加解扰意味着在link两端启动所有lane的加扰器和解扰器。
但采用混合模式，只对一个link中的固定几条lane启动加解扰器是不允许的。

加扰的主要目的是避免频谱出现过大的峰值，这就意味着过多的帧到帧之间重复数据传输。
在一个敏感的系统中，频谱的峰值会引起电磁不兼容或者互相干扰的问题。
过多相同帧也会引起基于编码的直流偏置。，
另一个加扰的好处就是使传输信道的频谱和数据区分开，这样接口上可能的频率选择效应就不会影响到数据的独立性。

\subsubsection{协议分析}

每一种扰码都有相对应的符合实际传输需求的扰码多项式，作为加扰和解扰的依据。
JESD204B协议规定的扰码多项式为$1+x^{14}+x^{15}$。
可见这个加扰多项式的周期长达32767位，足以符合敏感电磁系统频谱的要求。
并且他允许解扰器在接收到2个octet数据后达成自同步。

加扰器和解扰器的根据它们的串行实现，一帧一阵的处理发送和接受的数据。
一帧中最左边的位首先被转换，具体的转换顺序如图\ref{fig:serial_scrambling}所示。

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{./img/serial_scrambling.pdf}
\caption{扰码frame传输顺序}
\label{fig:serial_scrambling}
\end{figure}



\subsection{Frame/Lane对齐字符检测设计}

\bibliography{../../bib/serdes}
\end{document}

